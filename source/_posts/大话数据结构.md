---
title: 大话数据结构
categories: program
tags: 数据结构
---

-------

### 第一章 绪论



#### 1.4 概念和术语

数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。



#### 1.5 逻辑结构与物理结构

##### 1.5.1 逻辑结构：数据对象中数据元素之间的相互关系。

1. 集合结构：数据元素除了属于同一个集合外，之间没有其他关系。

2. 线性结构：一对一的关系。

3. 树形结构：存在一种一对多的曾册关系。

4. 图形结构：多对多的关系。

##### 1.5.2 物理结构：数据的逻辑结构在计算机中的存储形式。

数据的存储结构应正确反应数据元素之间的逻辑关系。

1. 顺序存储结构：把数据元素存放在地址连续的存储单元里，其数据件的逻辑关系和物理关系是一致的。
2. 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。用一个指针存放数据元素的地址，通过地址找到关联数据元素的位置。



#### 1.6 抽象数据类型

##### 1.6.1 数据类型

是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

在c语言中，按照取值的不同，数据类型可分为两类：

1. 原子类型：不可以再分解的基本类型，整型，实型，字符型等。
2. 结构类型：由若干个类型组合而成，可以分解，如数组等。

##### 1.6.2 抽象数据类型

指一个数学模型及定义在该模型上的一组操作。仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。

抽象数据类型体现了程序设计中问题分解，抽象和信息隐藏的特性。



-----

### 第二章 算法



#### 2.4 算法定义

算法是解决特定问题求解步骤的描述，在计算机中表现为指令的优先序列，并且每条指令表示一个或多个操作。



#### 2.5 算法的特性

算法具有五个基本特性：输入，输出，有穷性，确定性和可行性。



#### 2.6 算法设计的要求

1. 正确性：输入输出和加工处理无歧义性，能正确反映问题的需求，能得到问题的正确答案。

   一般情况下，算法是否正确的标准：对于非法的输入数据能够得出满足规格说明的结果。

2. 可读性：便于阅读，理解和交流。

3. 健壮性：输入数据不合法时，算法也能做出相关处理。

4. 时间效率高和存储量低。



#### 2.7 算法效率的度量方法

##### 2.7.1 事后统计方法

##### 2.7.2 事前分析估算方法

在计算机程序编制前，依据统计方法对算法进行估算。

一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：

1. 算法采用的策略，方法：算法好坏的根本。
2. 编译产生的代码质量：软件的支持。
3. 问题的输入规模。
4. 机器执行指令的速度：硬件性能。

在分析程序的运行时间时，重要的是把程序看成独立于程序设计语言的算法或一系列步骤。



#### 2.8 函数的渐近增长

**定义：** 给定两个函数 f(n) 和 g(n)，如果存在一个整数 N，使得对于所有 n > N，  f(n) 总是比 g(n) 大，那么我们说  f(n)  的增长渐近快于 g(n)。

判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项的阶数。



#### 2.9 算法时间复杂度

#####  2.9.1 定义：

在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析  T(n) 随 n 的变化情况并确定  T(n) 的数量级。算法的时间复杂度，也就是算法的时间量度，记作： T(n) = O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和  f(n) 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函数。一般情况下，随着 n 的增大， T(n) 增长最慢的算法为最优算法 。

##### 2.9.2 推导大 O 阶

1. 用常数 1 取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且不为 1，则去除与这个项相乘的常数。



#### 2.10 常见的时间复杂度

![image-20200616154806058](/Users/mac/Library/Application Support/typora-user-images/image-20200616154806058.png)



#### 2.12 算法空间复杂度

算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))，其中，n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数。



------

### 第三章 线性表 List

> 零个或多个数据元素的有限序列。

#### 3.3 线性表的抽象数据类型

```java
ADT 线性表(List)
Data
		数据元素类型相同，除第一个元素外，每个元素有且只有一个直接前驱元素，除了最后一个元素外，每个元素有且只有一个直接后继元素。数据元素之间的关系是一对一。
Operation
initList,listEmpty,clearList,getElem,locateElem,ListInsert,ListDelete,ListLength
endADT
```

#### 3.4 线性表的顺序存储结构

##### 3.4.1 定义

用一段地址连续的存储单元一次存储线性表的数据元素。

##### 3.4.4 地址计算方法

存储器中的每个存储单元都有自己的编号，这个编号称为地址。

假设每个数据占用 c 个存储单元，则： LOC(a[i+1]) =  LOC(a[i]) + c

可推出： LOC(a[i]) =  LOC(a[1]) + (i-1) c

#### 3.5 顺序存储结构的插入与删除

##### 3.5.1 获得元素操作

* 在数组下标范围内，直接返回。

##### 3.5.2 插入操作

* 插入位置不合理，抛出异常。
* 线性表长度大于或等于数组长度，抛出异常或增加容量。
* 插入的位置不在表尾，从最后向前遍历到第 i 个位置，向后移动一个位置。
* 将要插入元素填入位置 i。
* 表长加 1。

##### 3.5.3 删除操作

* 线性表为空，抛出异常。

* 删除位置不合理，抛出异常。
* 取出删除元素。
* 删除元素不在表尾，从删除位置遍历到最后。分别向前移动一个位置。
* 表长减 1。

##### 3.4.5 时间复杂度及优缺点

* 时间复杂度：

| 操作       | 时间复杂度 |
| ---------- | ---------- |
| 存，取     | O(1)       |
| 插入，删除 | O(n)       |

* 优点：无须为表示表中元素之间的逻辑关系而增加额外的存储空间；可以快速的存取表中任意位置的元素。
* 缺点：删除和插入操作需要移动大量元素；当线性表长度变化较大时，难以确定存储空间的容量；造成存储空间的碎片。

#### 3.6 线性表的链式存储结构

##### 3.6.4 代码描述

![image-20200617115130497](/Users/mac/Library/Application Support/typora-user-images/image-20200617115130497.png)

#### 3.7 单链表的读取

> 时间复杂度 O(n)

* 声明一个结点 p 指向链表第一个结点，初始化 j = 1。
* 当 j < i 时, 遍历链表，让 p 的指针向后移动，不断指向下一结点， j 累加 1。
* 循环结束 p 为空，元素不存在。
* 否则查找成功，返回结点 p 的数据。

#### 3.8 单链表的插入和删除

##### 3.8.1 插入的操作

![image-20200617134046716](/Users/mac/Library/Application Support/typora-user-images/image-20200617134046716.png)

#### 3.12 静态链表

用数组描述的链表叫做静态链表。我们让数组的元素都是由俩个数据域组成，data 和 cur，cur用来存放该元素的后继在数组中的下标。

##### 3.12.1 静态链表的插入操作



#### 3.13 循环链表

将单链表中终端结点的指针端由空指针改为指向头结点，这使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。



#### 3.14 双向链表





----

### 第四章 栈与队列

#### 4.2 栈的定义

栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶，另一端称为栈底，栈是后进先出的 *线性表*，简称 LIFO 结构。

#### 4.3 栈的抽象数据类型

![image-20200629165825378](/Users/mac/Library/Application Support/typora-user-images/image-20200629165825378.png)

#### 4.4 栈的顺序存储结构

##### 4.4.1 定义

栈的顺序存储其实是线性表顺序存储的简化，用数组下标为0的一端作为栈底。我们定义top变量指示栈顶元素在数组中的位置，栈的长度为 StackSize，栈顶位置top必须小于 StackSize。空栈的判定条件为 top < 0，

```javascript
// 结构
MAXSIZE = 10
const stack = {
  top: 0,
  data: Array[MAXSIZE]
}
```



##### 4.4.2 进栈操作

​	_时间复杂度 O(1)_

* 栈满/栈不存在，抛错
* 栈顶指针加一，元素赋值给栈顶空间

##### 4.4.3 出栈操作

​	_时间复杂度 O(1)_

* 栈空/栈不存在，抛错
* 返回删除的栈顶元素，栈顶指针减一

#### 4.5 两栈共享空间

![image-20200629172604612](/Users/mac/Library/Application Support/typora-user-images/image-20200629172604612.png)

#### 4.6 栈的链式存储结构

#### 4.10 队列

##### 4.10.1 定义

队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。队列是一种先进先出的线性表，简称 FIFO，允许插入的一端称为怼尾，允许删除的一端称为队头。

##### 4.10.2 抽象数据模型

![image-20200629175749918](/Users/mac/Library/Application Support/typora-user-images/image-20200629175749918.png)

#### 4.11 循环队列

##### 4.11.1 定义

队列头尾相接的顺序存储结构称为循环队列。

##### 4.11.2 存储结构

```js
const queue = {
	data: Array[10],
  front: 0,// 队头元素
  rear: 0 // 指向队尾元素的下一个位置
}
```

##### 4.11.3 队列长度

```js
// 不允许队列满，始终空一个元素空间
length = (rear + MAXSIZE - frone) % MAXSIZE
```

##### 4.11.4 入队操作

* 队满抛错

* 元素赋给队尾

* rear指针后移一位，若到最后则转到数组头部

  `rear=(rear+1)%MAXSIZE`

##### 4.11.4 出队操作

* 队空抛错

* 获取队头元素

* front指针后移一位，若到最后则转到数组头部

  front=(front+1)%MAXSIZE`

#### 4.12 队列的链式存储结构

队列的链式存储结构，其实就是线性表的单链表，不过只能尾进头出，简称为链队列。我们将队头指针指向链队列的头结点，队尾指针指向终端结点，空队列是，front 和 rear 都指向头结点。



----

### 第五章 串

#### 5.2 串的定义

串是由零个或多个字符组成的有限序列，又名叫字符串。

#### 5.3 串的比较

##### 5.3.1 字符编码

1. 拓展 ASCII 码:

   由 8 位二进制数表示一个字符，总共可以表示 256 个字符。

2. Unicode 编码:

   用 16 位的二进制数表示一个字符，约是 65 万多个字符。为了和 ASCII 码兼容，前 256 个字符与 ASCII 码完全相同。

##### 5.3.2 两串相等

长度和各个位置对应的字符都相等时，两串相等。

##### 5.4.3 两串不等

![image-20200630145234846](/Users/mac/Library/Application Support/typora-user-images/image-20200630145234846.png)

#### 5.4 串的抽象数据类型

串的逻辑结构和线性表相似，不同在于串针对字符集，关心的是查找子串位置，得到指定位置子串，替换子串等操作。![image-20200630145445898](/Users/mac/Library/Application Support/typora-user-images/image-20200630145445898.png)

#### 5.5 顺序存储和链式存储

#### 5.6 朴素的模式匹配算法

从头遍历，时间复杂度 O(n^2)

#### 5.7 KMP 模式匹配算法

克努特-莫里斯-普拉特算法，简称 KMP 算法。





-----

### 第六章 树

#### 6.2 树的定义

树是n个结点的有限集，n=0 时称为空树。在任意一颗非空树中:

1. 有且仅有一个特点的称为 根(Root) 的结点。
2. 当 n>1 时，其余结点可分为m(m>0) 个互不相交的有限集，其中每个集合本身又是一棵树，并且称为根的子树(SubTree)。

##### 6.2.1 结点分类

结点拥有的子树数称为结点的度(Degree)。度为 0 的结点称为叶结点 (Leaf) 或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根节点之外，分支结点也称为内部结点。数的度是树内各结点的度的最大值。

##### 6.2.2 结点间关系

孩子，双亲，祖先，子孙，兄弟，堂兄弟

##### 6.2.3 其他概念

1. 树中结点的最大层次称为书的深度(Depth) 或高度。
2. 如果将树中各结点的子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。
3. 森林(Forest) 是 m 棵互不相交的树的集合。对于树中每个结点而言，其子树的集合即为森林。

#### 6.3 树的抽象数据类型

![image-20200630164505292](/Users/mac/Library/Application Support/typora-user-images/image-20200630164505292.png)

#### 6.4 树的存储结构

利用顺序存储和链式存储结构的特点，实现对树的存储结构的表示。

##### 6.4.1 双亲表示法

在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。

```js
// 结点结构
const Node = {
  data: 1, // 数据域
  parent: 0, // 该结点的双亲在数组中的下标，根节点为 -1
}
// 树结构
const Tree = {
  nodes: Array[Node], // 结点数组
  root: 0, // 根的位置
  num: 10, // 结点树
}
```



##### 6.4.2 孩子表示法

把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针组成一个线性表，采用顺序存储结构，存放进一个一维数组中。

```js
// 孩子结点
const Child = {
  child: 1, // 该结点在表头数组中的下标
  next: 2 // 指向下一个孩子结点的指针
}
// 表头结构
const Node = {
  data: 'some thing', // 表头的数据域
  firstchild: child<Child> // 孩子链表的头指针
  parent: 3 // 双亲的下标，不存在时= -1
}
// 树结构
const Tree = {
  nodes: Array<Node>, // 结点数组
  root: 0, // 根节点的位置
  num: 10 // 结点数
}
```



##### 6.4.3 孩子兄弟表示法

存储头孩子结点和其右边兄弟的结点。

#### 6.5 二叉树

二叉树是n个节点的有限集合，该集合或者为空寂，或者由一个根节点和两棵互不相交的，分别称为根节点的左子树和右子树的二叉树组成。

##### 6.5.1 二叉树的五种基本形态:

空二叉树/只有一个根节点/根节点只有左子树/根节点只有右子树/根节点既有左子树又有右子树

##### 6.5.2 特殊二叉树

1. 斜树：所有的结点都只有左子树的二叉树叫左写书，所有结点都是右子树的二叉树叫右斜树。**斜树的特点是每层只有一个结点，结点的个数与二叉树的深度相同。**线性表可以理解为树的一种特殊表现形式。
2. 满二叉树：在一棵二叉树中，所有分支都存在左子树和右子树，所有的叶子在同一层。**特点：叶子只能出现在最下一层/非叶子结点的度一定是2/在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。
3. 完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同。

##### 6.5.3 完全二叉树特点

1. 叶子结点只能出现在最下两层
2. 最下层的叶子一定集中在左部连续位置
3. 倒数二层若有叶子结点一定在右部连续位置
4. 结点为1时至右左孩子
5. 同样结点数的二叉树，完全二叉树深度最小

#### 6.6 二叉树的性质

1. 第i层至多有 2^(i-1) 个结点
2. 深度为k时最多有 2^k - 1 个结点
3. 一棵二叉树 ![image-20200714174832141](/Users/mac/Library/Application Support/typora-user-images/image-20200714174832141.png)

4. ![image-20200714174909277](/Users/mac/Library/Application Support/typora-user-images/image-20200714174909277.png)

#### 6.7 二叉树的存储结构

##### 6.7.1 顺序存储

![image-20200714175240989](/Users/mac/Library/Application Support/typora-user-images/image-20200714175240989.png)

##### 6.7.2 二叉链表

![image-20200714175222815](/Users/mac/Library/Application Support/typora-user-images/image-20200714175222815.png)

#### 6.8 遍历二叉树

##### 6.8.1 遍历原理

二叉树的遍历是指从根节点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。

##### 6.8.2 遍历方法

1. 前序遍历： 若二叉树为空，则空操作返回，否则先访问根节点，再前序遍历左子树，再前序遍历右子树。
2. 中序遍历：若树为空，则空操作返回，否则从根节点开始，中序遍历根节点的左子树，然后访问根节点，最后中序遍历右子树。
3. 后序遍历：若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历左右子树，最后访问根节点。
4. 层序遍历：若树为空，空操作返回，否则从树的第一层，从上而下逐层遍历。在同一层中，按从左到右的顺序对结点逐个访问。

##### 6.8.3 算法

```js
function preOrderTraverse (BiTree T) {
  if (T === null) return // 为空 返回
  console.log(T.data) // 显示结点数据
  preOrderTraverse(T.lchild) // 前序遍历左子树
  preOrderTraverse(T.rchild) // 再先序遍历右子树
}
// 调整执行顺序即可分别实现前序，中序，后序遍历算法
```

#### 6.9 二叉树的建立

递归

#### 6.10 哈夫曼树

TODO



----

### 第七章 图

#### 7.2 图的定义

> 图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G(V,E), 其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

TODO



----

### 第八章 查找

#### 8.2 概论

##### 8.2.1 术语

* 查找表(Search table)： 由同一类型的数据元素或记录构成的集合。
* 关键字(Key)：数据元素中某个数据项的值，又称键值，若关键字可以唯一地表示一个记录，称为主关键字；对于可以识别多个数据元素的关键字，称为次关键字。
* 查找(Search)：根据给定的某个值，在查找表中去定一个其关键字等于给定值的数据元素。

##### 8.2.2 查找表类别

1. 静态查找表：只做查找操作的查找表。
2. 动态查找表：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。

#### 8.3 顺序表查找

顺序查找又叫线性查找，查找过程是，从表中第一个或者最后一个记录开始，逐个进行记录的关键字和给定值比较，若伯格记录的关键字和给定值相等，则查找成功；到最后一个都不等时，查找不成功。

时间复杂度： O(n)

##### 8.3.2 有哨兵顺序查找

```js
function serach2 (str, key) {
  let i = str.length
  const head = a[0]
  while (a[i] !== key && i > -1) {
    i --
  }
  if (i === 0 ) { // 判断 key 是否等于头部元素
    if (head === key) return 0
    return -1
  } else {
    return i
  }
  // 返回 -1 则说明查找失败
}
```

#### 8.4 有序表查找

##### 8.4.1 折半查找/二分查找

前提是线性表中的记录是关键码有序(通常从小到大)，线性表必须采用顺序存储。

时间复杂度：O(logn)

![image-20200716173726439](/Users/mac/Library/Application Support/typora-user-images/image-20200716173726439.png)

##### 8.4.2 插值查找

##### 8.4.3 斐波那契查找



#### 8.5 线性索引查找

对于增长较快的数据集，要保证记录中某个关键字有序，时间代价是非常高昂的，这种数据通常都是先后顺序存储。

对于这样的查找表我们引入了索引。

索引：是为了加快查找速度而设计的一种数据结构，**就是把一个关键字与它对应的记录相关联的过程**，一个索引由所感个索引项构成，每个索引项应至少包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库及磁盘文件的一种重要技术。

索引按照结构分为：线性索引，树形索引和多级索引。

##### 8.5.1 稠密索引

稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项。

对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。

##### 8.5.2 分块索引

分块有序，是把数据集的记录分成了若干块，且要满足以下两个条件：

1. 块内无序：每一块内的记录不要求有序。
2. 块间有序：如要求第二块所有记录的关键字均要大于第一块中记录的关键字。

定义：对于分块有序的数据集，将每块对应一个索引项。

定义的分块索引的索引项结构分三个数据项：

1. 最大关键码：每一块中的最大关键字。
2. 块中的记录个数。
3. 指向块首数据元素的指针，便于开始进行遍历。

##### 8.5.3 倒排索引

倒排索引源于实际应用中需要根据属性(或字段，次关键码)的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因为称为倒排索引。

#### 8.6 二叉排序树

1. 二叉树结点结构
2. 查找：递归
3. 插入： todo
4. 删除： todo

#### 8.7 平衡二叉树(AVL树)

平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差至多等于1。它是一种高度平衡的二叉排序树。将二叉树结点的左子树深度减去右子树深度的值称为平衡因子BF, 平衡因子只可能是-1,0和1。

距离插入结点最近的，且平衡因子的绝对值大于 1 的结点为根的子树，称为最小不平衡子树。

查找，插入和删除的时间复杂度：O(nlogn)

##### 8.7.1 实现原理



#### 8.8 多路查找树

每一个结点的孩子数可以多于两个，且每一个结点可以存储多个元素。

特殊形式：2-3树，2-3-4树，B树，B+树

##### 8.8.3 B树

是一种平衡的多路查找树，结点最大的孩子数目称为B树的阶，2-3树是3阶B树，2-3-4树是4阶B树。

一个m阶的B树具有如下属性：

* 如果根节点不是叶结点，则至少有两棵子树。
* 每一个非根的分支结点都有 k-1 个元素和 k 个孩子，其中 m/2 <= k <= m。
* 所有叶子结点都位于同一层次。

##### 8.8.4 B+树





#### 8.9 散列表查找(哈希表)概述

##### 8.9.1 定义

散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f。使得每个关键字 key 对应一个存储位置 f(key)。查找时，根据这个确定的对应关系找到给定值 key 的映射 f(key)，若查找集合中存在这个记录，则在 f(key) 的位置。

这种对应关系 f 称为散列函数，也叫哈希函数。采用散列技术存储记录的连续存储空间称为散列表或哈希表。关键字对应的记录存储位置称为散列地址。

##### 8.9.2 查找步骤

在存储和查找时，通过散列函数计算记录的散列地址，按照该地址存储或访问该记录。散列技术既是一种存储方法，也是一种查找方法。

散列技术的记录之间不存在逻辑关系，只与关键字有关，因此，散列主要是面向查找的存储结构。

冲突： 两个关键字不相等，地址相等，称为冲突，并把这两个关键字称为这个散列函数的同义词。

#### 8.10 散列函数的构造方法

1. 计算简单

   计算时间不应超过其他查找技术与关键字比较的时间。

2. 散列地址分布均匀

   可以保证存储空间的有效利用，并减少为处理冲突而耗费的时间。

#### 8.11 实现 todo





---

### 第九章 排序

#### 9.2 基本概念与分类

##### 9.2.1 排序的稳定性

如果两个记录相等，排序后位置不变，则是稳定的，否则称所用的排序方法是不稳定的。

##### 9.2.3 内排序与外排序

根据排序过程中待排序的记录是否全部被放置在内存中，排序分为内排序和外排序。

外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。

对于内排序来说，排序算法的性能受三个方面影响：

1. 时间性能
2. 辅助空间
3. 算法的复杂度

#### 9.3 冒泡排序

* 基本思想: 两两比较，反序则交换，直到没有反序的记录为止。

* 时间复杂度: O(n^2)

##### 9.3.1 冒泡排序算法

```js
function bubble (array) {
  const len = array.length
  if (!len) return

  for (let i = 0;i < len;i++) {
    for (let j = len-1;j > i;j--){
      if (array[j-1] > array[j]) {
        swap(array, j-1, j)
      }
    }
  }
}
```



##### 9.3.2 优化版

```js
function bubblePlus (array) {
   const len = array.length
  if (!len) return
  let flag = true
  for (let i = 0;i < len && flag;i++) {
    flag = false
    for (let j = len-1;j > i;j--){
      if (array[j-1] > array[j]) {
        swap(array, j-1, j)
        flag = true
      }
    }
  }
}
```



#### 9.4 简单选择排序

* 基本思想: 通过n-1次关键词的比较，从n-i+1个关键字中找到最小的关键字并和第i个关键字交换。
* 时间复杂度: O(n^2)

```js
function select (array) {
  const len = array.length
  if (!len) return array

  for (let i = 0;i < len;i++) {
    let temp = i
    for (let j = i; j < len;j++) {
      if (array[j] < array[temp]) temp = j
    }
    if (temp !== i) swap(array, temp, i)
  }
}
```



#### 9.5 直接插入排序

* 基本思想: 将一个记录插入到已经排好序的有序表中，从而得到一个新的记录加一的有序表。
* 时间复杂度: O(n^2)

```js
function insert (array) {
  const len = array.length
  if(!len) return array

  for (let i = 0; i < len; i++) {
    for (let j = i; array[j] < array[j-1] && j > -1; j--) {
      swap(array, j, j-1)
    }
  }
}
```



#### 9.6 希尔排序

* 基本思想: 也称递减增量排序算法，是插入排序的一种更高效的改进版本,希尔排序是非稳定排序算法。希尔排序的基本思想是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。
* 时间复杂度: 优于O(n^2)

```js
function shell(arr) {
    var len = arr.length,
        gap = 1;
    while(gap < len/3) { // 动态获取增量
        gap = gap * 3 + 1;
    }

    for (gap; gap > 0; gap = Math.floor(gap/3)) {
        for (var i = gap; i < len; i++) {
            let temp = arr[i];
            for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {
                arr[j+gap] = arr[j];
            }
            arr[j+gap] = temp;
        }
    }
    return arr;
}
```



#### 9.7 堆排序

* 时间复杂度: O(nlogn)

#### 9.8 归并排序

* 原理: 假设初始序列含有 n 个记录。则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到 n/2 个长度为 2 或者 1 的有序子序列，再两两归并，直到得到一个长度为n的有序序列为止。这种排序方法称为2路归并排序。

##### 9.8.1 递归实现

* 时间复杂度: O(nlogn)
* 空间复杂度: O(n+nlogn)

##### 9.8.1 非递归实现

* 空间复杂度: O(n)

#### 9.9 快速排序

* 时间复杂度: O(nlogn)
* 空间复杂度: O(logn)

```js
function quick (array, start, end) {
  if (start < end) {
    const piovt = getPiovt(array, start, end)
    quick(array, start, piovt-1)
    quick(array, piovt+1, end)
  }
}


function getPiovt(array, i, j) {
  const piovt = array[i]
  while (i < j) {
    while (i < j && array[j] >= piovt) {
      j--
    }
    array[i] = array[j]
    while (i < j && array[i] <= piovt) {
      i++
    }
    array[j] = array[i]
  }
  array[i] = piovt
  return i
}
```



##### 9.9.2 优化

1. 三数取中法

![image-20200724120846447](/Users/mac/Library/Application Support/typora-user-images/image-20200724120846447.png)

2. 不必要的交换



