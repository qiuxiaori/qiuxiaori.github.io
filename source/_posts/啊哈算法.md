---
title: 啊哈！ 算法
categories: 编程技术
tags: 数据结构与算法
---

### 第一章 排序

#### 1.0 交换算法

```js
function swap (array, i, j) {
    const temp = array[i]
    array[i] = array[j]
    array[j] = temp
}
```



#### 1.1 最快最简单的排序——桶排序

* 时间复杂度:  O(M+N)

```js
const bucket = function (array) {
  let nums = new Array(0,0,0,0,0,0,0,0,0,0)
  for (let i = 0; i < array.length; i ++) {
    nums[array[i]]++
  }
  for (let j = 9; j > -1; j --) {
    if (nums[j]) {
      for (let k = 0; k < nums[j]; k ++) console.log(j)
    }
  }
}
```

#### 1.2 冒泡排序

* 基本思想:每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。
* 时间复杂度:  O(N^2)

```js
const bubble = function (array) {
    const len = array.length
    if (len < 2) return array

    for (let i = 1;i < len;i ++) {
        for (let j = 1; j < len - i + 1; j ++) {
            if (array[j-1] > array[j]) {
                swap(array, j, j - 1)
            }
        }
    }
}
```

#### 1.3 快速排序

* 时间复杂度:  O(NlogN)

```js
const quick = function (array, start, end) {
    if (start > end) return
    const poivtIndex = getPoivtIndex(array, start, end)
    quick(array, start, poivtIndex - 1)
    quick(array, poivtIndex + 1, end)
}

// 获取基准数排序后的下标
const getPoivtIndex = function (array, start, end) {
    const poivt = start
    while (start < end) {
        while (start < end && array[end] > array[poivt]) {
            end --
        }
        while (start < end && array[start] <= array[poivt]) {
            start ++
        }
        if (start !== end) swap(array, start, end)
    }
    if (start !== poivt) swap(array, poivt, start)
    return start
}
```

#### 1.4 小哼买书 （去重排序

1. 先去重 再排序
2. 先排序 输出时再去重（判断与前一个数是否相同即可

