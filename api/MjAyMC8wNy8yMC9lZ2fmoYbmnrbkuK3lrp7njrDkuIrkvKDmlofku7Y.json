{"title":"egg框架中实现上传文件","date":"2020-07-20T07:05:18.548Z","date_formatted":{"ll":"Jul 20, 2020","L":"07/20/2020","MM-DD":"07-20"},"link":"2020/07/20/egg框架中实现上传文件","tags":["egg"],"categories":["编程技术"],"updated":"2021-04-25T15:38:12.654Z","content":"<blockquote>\n<p>接了个公司的需求，根据上传文件自动生成数据条目，egg 内置了 multipart 模块，之前没有使用过，就这次需求简要总结下使用方式和踩的坑。具体见 egg-multipart 的<a href=\"https://github.com/eggjs/egg-multipart\" target=\"_blank\">官方教程</a>。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"一.egg-multipart\">一.egg-multipart<a title=\"#一.egg-multipart\" href=\"#一.egg-multipart\"></a></h3>\n<ol>\n<li>配置使用</li>\n</ol>\n<ul>\n<li>\n<p>项目中 npm 安装 egg-multipart 插件<br>\n<code>npm i egg-multipart</code></p>\n</li>\n<li>\n<p>egg 项目的默认配置文件 config/config.default.js```js<br>\nexports.multipart = {<br>\nmode: ‘stream’, // 上传文件模式,[stream/file]<br>\nfileSize: ‘50mb’, // fileSize 默认是 10mb。如果上传较大的文件，需要指定此配置<br>\nwhitelist: [‘.png’], // 字符串数组，指定了允许上传的文件格式。会覆盖默认文件白名单，此时仅允许.png 格式文件<br>\nfileExtensions: [ ‘.xlsx’ ], // 可选，定制其他白名单没有的文件格式<br>\n};</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 默认内置白名单&#96;&#96;&#96;js</span><br><span class=\"line\">whitelist &#x3D; [</span><br><span class=\"line\">  &#x2F;&#x2F; images 支持</span><br><span class=\"line\">  &#39;.jpg&#39;, &#39;.jpeg&#39;,&#39;.png&#39;, &#39;.gif&#39;, &#39;.bmp&#39;, &#39;.wbmp&#39;, &#39;.webp&#39;,&#39;.tif&#39;,&#39;.psd&#39;,</span><br><span class=\"line\">  &#x2F;&#x2F; text</span><br><span class=\"line\">  &#39;.svg&#39;,&#39;.js&#39;, &#39;.jsx&#39;, &#39;.json&#39;,&#39;.css&#39;, &#39;.less&#39;,&#39;.html&#39;, &#39;.htm&#39;,&#39;.xml&#39;,</span><br><span class=\"line\">  &#x2F;&#x2F; tar</span><br><span class=\"line\">  &#39;.zip&#39;,&#39;.gz&#39;, &#39;.tgz&#39;, &#39;.gzip&#39;,</span><br><span class=\"line\">  &#x2F;&#x2F; video</span><br><span class=\"line\">  &#39;.mp3&#39;,&#39;.mp4&#39;,&#39;.avi&#39;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>白名单里没有的文件格式一定要添加到 fileExtensions 中，否则会报下面的错误。<br>\n<code>nodejs.Error: Invalid filename</code></li>\n</ul>\n<ol start=\"2\">\n<li>file 模式<br>\n如果您不知道 Node.js Stream 工作方式，也许您应该使用该 file 模式开始。用法与 bodyParser 非常相似。```js<br>\nctx.request.body：获取所有多部分字段和值，除了 file 文件。<br>\nctx.request.files：包含 file 来自 multipart 请求的所有内容，它是一个 Array 对象。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. stream模式</span><br><span class=\"line\">如果您熟悉Node.js Stream的工作原理，那么您应该使用该stream模式。&#96;&#96;&#96;js</span><br><span class=\"line\">ctx.getFileStream(): 获取文件流</span><br><span class=\"line\">ctx.getFileStream().fields: 获取所有多部分字段和值，它是一个Array对象。</span><br><span class=\"line\">ctx.getFileStream(&#123; requireFile: false &#125;): 文件非必须</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>文件的常用属性```js<br>\nfieldname: 文件名<br>\nencoding: 文件的编码格式<br>\nmime: 文件的 mime<br>\nfilepath: 文件的路径</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 二.具体实现</span><br><span class=\"line\">1. 安装插件&#96;&#96;&#96;js</span><br><span class=\"line\">npm i await-stream-ready    &#x2F;&#x2F; 用于异步操作文件</span><br><span class=\"line\">npm i stream-wormhole       &#x2F;&#x2F; 关闭文件流</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>引入模块```js<br>\n// loadService.js<br>\nconst fs = require(‘fs’); // node 的 fs 文件模块<br>\nconst path = require(‘path’); // node 的 path 路径模块<br>\n// 刚刚安装的插件<br>\nconst awaitWriteStream = require(‘await-stream-ready’).write;<br>\nconst sendToWormhole = require(‘stream-wormhole’);</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. 上传文件&#96;&#96;&#96;js</span><br><span class=\"line\">&#x2F;&#x2F; loadService.js</span><br><span class=\"line\">async addStoryByFile() &#123;</span><br><span class=\"line\">  const &#123; ctx, app &#125; &#x3D; this;</span><br><span class=\"line\">  con t stream &#x3D; await this.ctx.getFileStream(); &#x2F;&#x2F; egg 中获取上传文件的方法</span><br><span class=\"line\">  const filename &#x3D; stream.filename;</span><br><span class=\"line\">  const target &#x3D; path.join(&#39;app&#x2F;public&#x2F;uploads&#39;, filename);</span><br><span class=\"line\">  if(!fs.exitsSync(url)) &#123; &#x2F;&#x2F; 如果路径不存在，则创建</span><br><span class=\"line\">    fs.mkdir(url);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  const writeStream &#x3D; fs.createWriteStream(target); &#x2F;&#x2F; 创建文件流</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    await awaitWriteStream(stream.pipe(writeStream)); &#x2F;&#x2F; 异步写入文件</span><br><span class=\"line\">  &#125; catch (err) &#123;</span><br><span class=\"line\">    await sendToWormhole(stream); &#x2F;&#x2F; 如果失败，关闭文件流</span><br><span class=\"line\">    &#x2F;&#x2F; 其他操作</span><br><span class=\"line\">    &#x2F;&#x2F; return ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三.关于-egg-中文件上传的单元测试踩坑记\">三.关于 egg 中文件上传的单元测试踩坑记<a title=\"#三.关于-egg-中文件上传的单元测试踩坑记\" href=\"#三.关于-egg-中文件上传的单元测试踩坑记\"></a></h3>\n<p>egg 的单元测试本身是很简单的，但是文件上传有几个小坑，因为 multipart 插件要求传输头的 Content-Type 是 multipart/form-data 类型的，在测试时尝试了很多方法都没法把 mock 的 ctx 设置传输头。翻了很多文档，service 层的文件上传测试依然没找到解决方法，希望日后能找到把，目前只找到了 controller 层测试文件上传的方法，如下```js<br>\n‘use strict’;<br>\nconst { app, assert, mock } = require(‘egg-mock/bootstrap’); // 引入 egg 封装好的 mock 模块<br>\nconst fs = require(‘fs’); //引入文件模块<br>\ndescribe(‘test/app/service/story.test.js’, () =&gt; {<br>\nit(‘should add story’, async () =&gt; {<br>\nconst ctx = await app.httpRequest()<br>\n.post(‘/api/project/story/addStoryByFile’)<br>\n.field(‘workspace_id’, ‘62604516’) // 上传文件时不能使用 send 方法，要使用 field 发送参数，多个参数时级联 field<br>\n.field(‘iteration_id’, ‘116260451600100098’)<br>\n.attach(‘file’, ‘/Users/zmy/Downloads/爱云校研发管理 v1.0/data/document.js’); // 要上传的文件路径,必须在 field 后调用<br>\nassert(ctx.body.code === 0); // 返回的参数在 result 的 body 中<br>\n});<br>\n});</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">参考文献：</span><br><span class=\"line\"></span><br><span class=\"line\">1. [egg github上的test实例](https:&#x2F;&#x2F;github.com&#x2F;eggjs&#x2F;examples)</span><br><span class=\"line\">2. [egg 官网单元测试](https:&#x2F;&#x2F;eggjs.org&#x2F;zh-cn&#x2F;core&#x2F;unittest.html)</span><br><span class=\"line\">3. [egg单元测试mock api](https:&#x2F;&#x2F;github.com&#x2F;eggjs&#x2F;egg-mock#api)</span><br></pre></td></tr></table></figure>\n","prev":{"title":"node.js游戏服务器框架pomelo初试","link":"2020/07/20/node.js游戏服务器框架pomelo初试"},"next":{"title":"Hexo博客杂项","link":"2020/07/20/Hexo博客杂项"},"plink":"http://qiuxiaori.github.com/2020/07/20/egg框架中实现上传文件/","toc":[{"id":"一.egg-multipart","title":"一.egg-multipart","index":"1"},{"id":"三.关于-egg-中文件上传的单元测试踩坑记","title":"三.关于 egg 中文件上传的单元测试踩坑记","index":"2"}],"copyright":{"author":"Qiu Xiaori","license":"自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0)","link":"<a href=\"http://qiuxiaori.github.com/2020/07/20/egg框架中实现上传文件/\" title=\"egg框架中实现上传文件\">http://qiuxiaori.github.com/2020/07/20/egg框架中实现上传文件/</a>"}}