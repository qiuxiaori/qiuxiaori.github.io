{"title":"Node深入浅出","date":"2020-08-10T08:45:56.506Z","date_formatted":{"ll":"Aug 10, 2020","L":"08/10/2020","MM-DD":"08-10"},"link":"2020/08/10/Node深入浅出","tags":["node"],"categories":["编程技术"],"updated":"2020-08-10T16:44:23.141Z","content":"<h3 id=\"一.-什么是node\">一. 什么是Node<a title=\"#一.-什么是node\" href=\"#一.-什么是node\"></a></h3>\n<h5 id=\"node.js是一个运行环境\">Node.js是一个运行环境<a title=\"#node.js是一个运行环境\" href=\"#node.js是一个运行环境\"></a></h5>\n<p>**Node.js使用c++语言编写而成，是一个 javascript 语言运行环境。Node.js 采用了 Chrome 浏览器的 V8 引擎，性能很好，同时提供了很多系统级的 API。**浏览器端的 javascript 代码在运行时会收得到各种安全性的限制，对客户系统的操作有限，而 Node.js 是一个全面的后台运行时，为javascript 提供了其他语言能够实现的许多功能。</p>\n<h5 id=\"node.js的特点\">Node.js的特点<a title=\"#node.js的特点\" href=\"#node.js的特点\"></a></h5>\n<ul>\n<li>采用事件驱动,异步编程，为网络服务而设计</li>\n<li>以单进程，单线程模式运行，<strong>事件驱动机制</strong>是Node.js通过内部单线程高效率的维护<strong>事件循环队列</strong>来实现的，没有多线程的资源占用和上下文切换开销。</li>\n<li>支持的语言是 javascript。javascript的匿名函数和闭包特性非常适合事件驱动，异步编程。</li>\n</ul>\n<hr>\n<h3 id=\"三.-模块机制\">三. 模块机制<a title=\"#三.-模块机制\" href=\"#三.-模块机制\"></a></h3>\n<h5 id=\"commonjs--规范\">CommonJS  规范<a title=\"#commonjs--规范\" href=\"#commonjs--规范\"></a></h5>\n<p>CommonJS规范的出现，目标是为了构建 Javascript 在包括Web服务器，桌面，命令行工具以及浏览器方面的生态系统。</p>\n<p>CommonJS指定了解决这些问题的一些规范，而Node.js就是这些规范的一种实现。</p>\n<p><strong>Node.js自身实现了 require 方法作为其引入模块的方法，同时 NPM 也基于 CommonJS 定义的包的规范，实现了依赖管理和模块自动安装等功能。</strong></p>\n<h5 id=\"简单模块定义和使用\">简单模块定义和使用<a title=\"#简单模块定义和使用\" href=\"#简单模块定义和使用\"></a></h5>\n<ul>\n<li>导出：如果模块返回的函数或变量不止一个，那它可以通过设定exports对象的属性来指明它们。但如果模块只返回一个函数或变量，则可以设定在module.exports属性。最终在程序里导出的是module.exports，exports只是对module.exports的一个全局引用，最初被定义为一个可以添加属性的空对象。所以exports.myFunc只是 module.exports.myFunc的简写。</li>\n<li>引入：require(‘./fileName’)。如果模块是 个目录，Node通常会在这个目录下找一个叫index.js的文件作为模块的入口。</li>\n</ul>\n<h5 id=\"模块分类\">模块分类<a title=\"#模块分类\" href=\"#模块分类\"></a></h5>\n<ul>\n<li>原生模块：在源代码编译的时候编译进了二进制执行文件，加载的速度最快。原生模块都被定义在lib这个目录下。</li>\n<li>文件模块：动态加载，加载速度比原生模块慢。\n<ul>\n<li>.js：通过fs模块同步读取js文件并编译执行</li>\n<li>.node：通过c/c++进行编写的Addon，通过dlopen方法进行加载</li>\n<li>.json：读取文件，调用JSON.parse解析加载</li>\n</ul>\n</li>\n</ul>\n<p>node对模块都进行了缓存，在第二次require时，不会有重复开销的。</p>\n<h5 id=\"文件模块的加载\">文件模块的加载<a title=\"#文件模块的加载\" href=\"#文件模块的加载\"></a></h5>\n<p>加载文件模块的工作主要由原生模块module完成和实现，该模块在启动时已经被加载，进程直接调用到 runMain 静态方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Module.runMain = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  Module._load(process.argv[<span class=\"number\">1</span>], <span class=\"literal\">null</span>, ture)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>_load 静态方法在分析文件名后执行实例化</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = <span class=\"keyword\">new</span> Module(id, parent)</span><br></pre></td></tr></table></figure>\n<p>并根据文件路径缓存当前模块对象，该模块实例对象则根据文件名加载</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.load(filename)</span><br></pre></td></tr></table></figure>\n<p>require方法实际上调用的就是load方法，load方法在载入编译缓存了module后，返回module的exports对象。</p>\n<h5 id=\"require方法中的文件查找策略\">require方法中的文件查找策略<a title=\"#require方法中的文件查找策略\" href=\"#require方法中的文件查找策略\"></a></h5>\n<p>文件模块缓存-&gt;原生模块-&gt;文件加载(逐层查找module path)-&gt;npm包</p>\n<hr>\n<h3 id=\"四.事件机制\">四.事件机制<a title=\"#四.事件机制\" href=\"#四.事件机制\"></a></h3>\n<p>基于v8引擎实现的事件驱动IO。</p>\n<hr>\n<h3 id=\"五.-异步i/o实现\">五. 异步I/O实现<a title=\"#五.-异步i/o实现\" href=\"#五.-异步i/o实现\"></a></h3>\n<h5 id=\"异步i/o\">异步I/O<a title=\"#异步i/o\" href=\"#异步i/o\"></a></h5>\n<p>在操作系统中，程序运行的空间分为内核空间和用户空间，我们提到的异步I/O，实质是用户空间的程序不用依赖内核空间中的I/O操作实际完成，即可进行后续任务。时间开销为m+n的两个任务会减小为max(m,n)</p>\n<h5 id=\"必要性\">必要性<a title=\"#必要性\" href=\"#必要性\"></a></h5>\n<p>避免了多线程的资源占用和上下文切换的开销。</p>\n<h5 id=\"理想的异步i/o模型\">理想的异步I/O模型<a title=\"#理想的异步i/o模型\" href=\"#理想的异步i/o模型\"></a></h5>\n<p>理想的模型是在应用程序发起异步调用而不需要进行轮训，进而处理下一个任务，只需要在I/O完成后通过信号或事回调将数据传递给应用程序。</p>\n<ul>\n<li>linux：libeio</li>\n<li>windows：IOCP</li>\n</ul>\n<p>node提供了libuv来作为抽象封装层，平台判断在一层完成。node在编译期间会判断平台条件，选择性编译unix目录或事win目录下的源文件到目标程序中。</p>\n<h5 id=\"node.js的异步i/o模型\">Node.js的异步I/O模型<a title=\"#node.js的异步i/o模型\" href=\"#node.js的异步i/o模型\"></a></h5>\n","prev":{"title":"白苹果解决办法","link":"2020/08/25/白苹果解决办法"},"next":{"title":"http学习","link":"2020/08/04/http学习"},"plink":"http://qiuxiaori.github.com/2020/08/10/Node深入浅出/","toc":[{"id":"一.-什么是node","title":"一. 什么是Node","index":"1"},{"id":"三.-模块机制","title":"三. 模块机制","index":"2"},{"id":"四.事件机制","title":"四.事件机制","index":"3"},{"id":"五.-异步i/o实现","title":"五. 异步I&#x2F;O实现","index":"4"}],"copyright":{"author":"Qiu Xiaori","license":"自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0)","link":"<a href=\"http://qiuxiaori.github.com/2020/08/10/Node深入浅出/\" title=\"Node深入浅出\">http://qiuxiaori.github.com/2020/08/10/Node深入浅出/</a>"}}